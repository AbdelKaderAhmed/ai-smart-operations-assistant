import json
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from sqlalchemy.orm import Session
from typing import List, Optional

from backend.app.llm.client import ai_client
from backend.app.functions.registry import FUNCTION_REGISTRY
from backend.app.db.session import get_db
from backend.app.models.operation import Operation

router = APIRouter()

class UserCommand(BaseModel):
    command: str

@router.post("/analyze")
async def analyze_command(user_request: UserCommand, db: Session = Depends(get_db)):
    try:
        # 1. Get the AI decision from the LLM (Groq/OpenAI)
        ai_message = ai_client.get_ai_decision(user_request.command)
        
        if not ai_message:
            raise Exception("AI returned an empty response")

        # 2. Extract tool calls (functions) from the AI response
        tool_calls = getattr(ai_message, 'tool_calls', None)

        if tool_calls:
            tool_call = tool_calls[0]
            function_name = tool_call.function.name
            
            # These are the arguments generated by AI (e.g., recipient, content, subject)
            function_args = json.loads(tool_call.function.arguments)
            
            # 3. Find the matching executor in our registry
            executor = FUNCTION_REGISTRY.get(function_name)
            
            if executor:
                # 4. Execute the actual logic (Send email or Schedule meeting)
                result = await executor.execute(**function_args)
                
                # 5. FIX: Save the AI'S ARGUMENTS to the database, not just the result message.
                # This ensures the Frontend has the email body/subject to display.
                db_save_data = json.dumps(function_args)
                
                # 6. Create the operation record in the database
                new_op = Operation(
                    command=user_request.command,
                    intent=function_name,
                    status="success",
                    response_data=db_save_data
                )
                db.add(new_op)
                db.commit()

                # Return response to the Frontend
                return {
                    "intent": "action_executed",
                    "function": function_name,
                    "execution_result": result,
                    "assistant_message": f"Operation {function_name.replace('_', ' ')} completed successfully."
                }
            else:
                return {"error": f"Function {function_name} is not registered in Backend."}
        
        # 7. Fallback: If no tool was called, handle it as a standard text chat
        content = getattr(ai_message, 'content', "I couldn't process that request.")
        
        new_op = Operation(
            command=user_request.command,
            intent="text_response",
            status="success",
            response_data=json.dumps({"message": content})
        )
        db.add(new_op)
        db.commit()

        return {
            "intent": "text_response",
            "assistant_message": content
        }
        
    except Exception as e:
        # Log error for debugging
        print(f"ðŸ”´ Backend Error: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/history")
async def get_operations_history(db: Session = Depends(get_db), limit: int = 10):
    """
    Fetch the most recent operation logs for the sidebar and modals.
    """
    operations = db.query(Operation).order_by(Operation.created_at.desc()).limit(limit).all()
    return operations

@router.delete("/{op_id}")
async def delete_operation(op_id: int, db: Session = Depends(get_db)):
    """
    Remove a specific operation log from the database.
    """
    operation = db.query(Operation).filter(Operation.id == op_id).first()
    if not operation:
        raise HTTPException(status_code=404, detail="Operation not found")
    
    db.delete(operation)
    db.commit()
    return {"message": f"Operation {op_id} deleted successfully"}